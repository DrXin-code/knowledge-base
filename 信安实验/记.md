4. 

5.静态库
一组目标文件( .o/ .obj文件)的集合
·与汇编生成的目标文件.o一起链接打包到可执行文件中特点︰
·链接是在编译阶段完成
·程序运行时与函数库再无瓜葛，移植方便
·可执行文件巨大，包含所有相关目标文件与涉及函数库

函数库
>现有的，成熟的，可复用的代码>根据链接方式，可分为∶
>·静态库: .a ( Linux ) ..lib ( Windows )·动态库: .so ( Linux ) 、.dll ( Windows )>Linux下命名规则:lib<函数库名称>.<a/so>

·处理宏定义指令·处理条件编译指令扩展头文件包含指令

（1）编译生成目标文件
$ gcc –c add.c -I. –o add.o
$ gcc –c main.c -I. –o main.o
\# （2）生成静态库
$ ar -crv libadd.a add.o
\# -c：创建静态库
\# -r：将目标文件加入静态库
\# -v：显示处理信息
\# 注：函数库名前须加lib，后缀名为.a
\# （3）静态链接
$ gcc main.o -L. -ladd -o main
\# -l<函数库名>：指明需要链接的函数库
将当前目录纳入系统头文件搜索路径
将当前目录纳入系统函数库搜索路径

\# 命令流程
\# （1）编译生成动态库
$ gcc –fPIC -shared add.c -I. –o libadd.so
\# -fPIC：创建与地址无关的程序
\# -shared：生成动态链接库
\# （2）动态链接
$ gcc main.c -L. -ladd -o main
\# 注：须增加动态链接库搜索路径
$ sudo vim /etc/ld.so.conf #增加动态库路径
$ sudo ldconfig

静态库和动态库都有各自的优点和缺点，选择使用哪一种取决于项目的需求和特定的使用场景。

### 静态库的优缺点：

#### 优点：

1. **独立性：** 静态库在链接阶段被完全包含在可执行文件中，使得可执行文件在运行时不依赖外部库。这提高了程序的独立性，减少了对系统环境的依赖。

2. **性能：** 由于静态库已经在编译时被链接到可执行文件中，因此在运行时不需要加载和链接外部库，可能导致启动速度更快，但这在大多数情况下并不是显著的性能提升。

3. **可移植性：** 由于静态库已经包含在可执行文件中，因此程序在不同系统上运行时不需要关心库的版本问题，提高了可移植性。

#### 缺点：

1. **体积：** 可执行文件的体积较大，因为它包含了所有被静态库使用的代码，这可能导致较大的可执行文件。

2. **更新维护：** 如果静态库的代码发生变化，整个程序都需要重新编译和链接。这可能使得更新和维护变得繁琐，尤其是对于大型项目而言。

3. **资源利用：** 如果多个可执行文件使用同一份静态库，每个可执行文件都会包含一份相同的库代码，浪费了系统资源。

### 动态库的优缺点：

#### 优点：

1. **共享性：** 多个程序可以共享同一份动态库，减少了系统资源的浪费，因为动态库只加载一次到内存中。

2. **更新维护：** 如果动态库的代码发生变化，只需替换库文件而无需重新编译和链接程序，这使得更新和维护更加方便。

3. **体积：** 相对于静态库，可执行文件的体积较小，因为动态库的代码在运行时才加载。

#### 缺点：

1. **依赖性：** 程序在运行时需要动态库存在，如果系统中没有相应版本的库或者路径配置不正确，可能导致程序无法运行。

2. **启动速度：** 由于动态库在运行时加载，可能导致程序启动速度相对较慢，尤其是对于一些小型程序而言。

3. **版本兼容性：** 动态库需要处理版本兼容性问题，确保程序与系统上存在的正确版本的库兼容。这可能会导致一些额外的管理和维护工作。

综合考虑，选择静态库还是动态库通常取决于项目的需求、性能要求、可维护性以及对可执行文件大小的关注。在某些情况下，混合使用静态库和动态库也是一种常见的做法。

1. **手册页面不存在：** 确保 OpenSSL 库已经正确安装，并且你的系统支持 OpenSSL 的手册页面。你可以尝试安装 OpenSSL 的手册页面，具体方法可能因系统而异。例如，在基于 Debian 的系统上，你可以运行以下命令安装 OpenSSL 的手册页面：

   ```bash
   sudo apt-get install libssl-doc
   ```

   **2.openssl** 安装


```bash
	sudo apt-get install libssl-dev
```

### 声明

对称密码和非对称密码是两种常见的密码学算法，它们各自具有一些优点和缺点。

### 对称密码：

#### 优点：

1. **速度快：** 对称密码通常比非对称密码更快速，因为加密和解密使用相同的密钥。
2. **简单：** 实施相对简单，适合大量数据的加密。
3. **适合对大数据流进行加密：** 由于速度快，对称密码适用于对大量数据进行实时加密和解密的场景，如数据传输和存储。

#### 缺点：

1. **密钥管理：** 密钥分发和管理是一个挑战，尤其是在分布式系统中，因为每对通信方都需要共享相同的密钥。
2. **不适合密钥交换：** 如果通信双方不事先共享密钥，就需要使用其他机制（如非对称密码）来进行密钥交换，这增加了复杂性。

### 非对称密码：

#### 优点：

1. **密钥交换：** 非对称密码解决了对称密码中的密钥管理问题，因为每个实体都有一对公私钥，而只需将公钥传递给其他人。
2. **数字签名：** 非对称密码可用于数字签名，验证消息的发送者，确保消息的完整性和真实性。
3. **更安全的密钥管理：** 不需要在通信双方之间共享密钥，减少了密钥管理的复杂性。

#### 缺点：

1. **速度慢：** 相对于对称密码，非对称密码通常更慢，因为加密和解密使用不同的密钥。
2. **复杂性：** 实施和理解起来比对称密码更复杂。
3. **不适合大数据流：** 由于速度较慢，非对称密码不太适合对大量数据进行实时加密和解密。

在实际应用中，通常使用对称密码和非对称密码的组合，即混合密码系统，以充分利用它们各自的优点，同时弥补彼此的缺点。例如，使用对称密码加密大量数据，而使用非对称密码进行密钥交换和数字签名。这种方法称为混合加密。

流密码是一种对称密码系统，它与块密码不同，它按比特（bit）或字节的顺序逐个加密数据流。流密码的优缺点如下：



流密码是一种对称加密算法，它使用伪随机流与明文按位异或进行加密。以下是关于流密码的一些特点和适用情境：

### 特点：

1. **对称加密：** 流密码是一种对称加密算法，加解密使用相同的密钥。

2. **伪随机流：** 加解密双方通过密钥产生相同的伪随机流，该流用于与明文按位异或，从而实现加密和解密。

3. **加密单位：** 流密码的加密单位是比特位，它按位处理明文和伪随机流。

4. **低错误传播：** 流密码在传输过程中对错误的容忍性较高，因为每个比特位的错误通常仅影响对应位置的明文比特，而不会扩散到其他部分。

5. **硬件实现简单：** 流密码通常在硬件上实现相对简单，因为它涉及对比特位的基本操作，例如异或。

### 适用情境：

1. **较高传输错误的通信环境：** 由于流密码对错误的容忍性较高，它适用于通信环境中存在较高传输错误的情况。这使得流密码在一些无线通信和不稳定信道的场景中有一定的优势。

2. **硬件资源受限：** 流密码的硬件实现相对简单，适用于资源受限的环境，例如嵌入式系统或物联网设备。

### 缺点：

1. **扩散度低：** 流密码在信息传播上的扩散度相对较低。这意味着单个明文比特的错误不会在解密过程中扩散到其他比特，但也可能导致密文中的错误不容易被发现。

2. **密钥管理：** 与对称密码一样，流密码需要有效的密钥管理系统来确保安全性，包括密钥的生成、分发和更新。

总体而言，流密码适用于一些特定的通信场景，特别是在考虑到传输错误的情况下。然而，密钥管理和扩散度的问题需要谨慎考虑，具体选择应根据特定应用的需求和安全性要求。


分组密码应用模式—ECB
Ø使用分组密码处理包含多个分组长度的数据的加解密操作
ØECB模式：
• 并行加密
• 并行解密
• 随机访问

分组密码应用模式—ECB
Ø使用分组密码处理包含多个分组长度的数据的加解密操作
ØECB模式：
• 并行加密
• 并行解密
• 随机访问
• 安全隐患 原始图像 ECB加密结果

分组密码应用模式—CBC
ØCBC模式：
• 依赖初始向量IV
• 公开，随机
• 串行加密
• 并行解密
• 随机访问

分组密码应用模式—CTR
ØCTR模式：
• 依赖Nonce
• 公开，随机，非重复
• 并行加密
• 并行解密
• 随机访问
• 预加密[Speculative Encryption, FAST’19]